---
AWSTemplateFormatVersion: '2010-09-09'
Description: Shared Services - 3-tier 3-AZ VPC
Parameters:
  VPCName:
    Description: Name of vpc - dev, test, np, prd
    Type: String
    Default: dev
  CIDRVPC:
    Description: CIDR block for the entire VPC
    Type: String
    Default: 10.0.0.0/16
  CIDRPublicSummary:
    Description: CIDR summary block for Public
    Type: String
    Default: 10.0.0.0/22
  CIDRPublicA:
    Description: CIDR block for Public Zone A
    Type: String
    Default: 10.0.0.0/24
  CIDRPublicB:
    Description: CIDR block for Public Zone B
    Type: String
    Default: 10.0.1.0/24
  CIDRPublicC:
    Description: CIDR block for Public Zone C
    Type: String
    Default: 10.0.2.0/24
  CIDRPrivateSummary:
    Description: CIDR summary block for Private (if any)
    Type: String
    Default: 10.0.4.0/22
  CIDRPrivateA:
    Description: CIDR block for Private Zone A
    Type: String
    Default: 10.0.4.0/24
  CIDRPrivateB:
    Description: CIDR block for Private Zone B
    Type: String
    Default: 10.0.5.0/24
  CIDRPrivateC:
    Description: CIDR block for Private Zone C
    Type: String
    Default: 10.0.6.0/24
  CIDRRestrictedSummary:
    Description: CIDR summary block for Restricted (if any)
    Type: String
    Default: 10.0.8.0/22
  CIDRRestrictedA:
    Description: CIDR block for Restricted Zone A
    Type: String
    Default: 10.0.8.0/24
  CIDRRestrictedB:
    Description: CIDR block for Restricted Zone B
    Type: String
    Default: 10.0.9.0/24
  CIDRRestrictedC:
    Description: CIDR block for Restricted Zone C
    Type: String
    Default: 10.0.10.0/24
  FlowLogRetentionPeriod:
    Description: Flow log retention in days
    Type: Number
    Default: 180
  RedundantNAT:
    Description: Should a NAT gateway be created in each AZ?
    Type: String
    Default: "False"
    AllowedValues:
      - "True"
      - "False"
  DomainName:
    Description: Domain name
    Type: String
    Default: "."

Conditions:
  ShouldCreateRedundantNAT:
    !Equals ["True", !Ref RedundantNAT]
  NoRedundantNAT:
    !Equals ["False", !Ref RedundantNAT]
  CreateHostedZone:
    !Not [ !Equals [ !Ref DomainName, "." ] ]

Resources:
  NetworkStackParam:
    Type: AWS::SSM::Parameter
    Properties:
      Description: References the VPC stack name
      Type: String
      Name: '/network-stack'
      Value: !Sub '${AWS::StackName}'

  VPC:
    Description: The VPC
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: !Ref 'CIDRVPC'
      EnableDnsHostnames: 'true'
      EnableDnsSupport: 'true'
      Tags:
      - Key: Name
        Value: !Sub "${VPCName}-VPC"
  SubnetPublicA:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref 'VPC'
      CidrBlock: !Ref 'CIDRPublicA'
      AvailabilityZone: !Sub "${AWS::Region}a"
      Tags:
      - Key: Name
        Value: !Sub "${VPCName}-public-a"
  SubnetPublicB:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref 'VPC'
      CidrBlock: !Ref 'CIDRPublicB'
      AvailabilityZone: !Sub "${AWS::Region}b"
      Tags:
      - Key: Name
        Value: !Sub "${VPCName}-public-b"
  SubnetPublicC:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref 'VPC'
      CidrBlock: !Ref 'CIDRPublicC'
      AvailabilityZone: !Sub "${AWS::Region}c"
      Tags:
      - Key: Name
        Value: !Sub "${VPCName}-public-c"
  InternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
      - Key: Name
        Value: !Sub "${VPCName}-igw"
  VPCGatewayAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      InternetGatewayId: !Ref 'InternetGateway'
      VpcId: !Ref 'VPC'
  RouteTablePublic:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref 'VPC'
      Tags:
      - Key: Name
        Value: !Sub "${VPCName}-public"
  RoutePublic:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref 'RouteTablePublic'
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref 'InternetGateway'
  SubnetRouteTableAssociationPublicA:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref 'SubnetPublicA'
      RouteTableId: !Ref 'RouteTablePublic'
  SubnetRouteTableAssociationPublicB:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref 'SubnetPublicB'
      RouteTableId: !Ref 'RouteTablePublic'
  SubnetRouteTableAssociationPublicC:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref 'SubnetPublicC'
      RouteTableId: !Ref 'RouteTablePublic'
  NetworkAclPublic:
    Type: AWS::EC2::NetworkAcl
    Properties:
      VpcId: !Ref 'VPC'
      Tags:
      - Key: Name
        Value: !Sub "${VPCName}-NACL-public"
  NetworkAclEntryPublicInboundAll:
    Type: AWS::EC2::NetworkAclEntry
    Properties:
      NetworkAclId: !Ref 'NetworkAclPublic'
      RuleNumber: '100'
      Protocol: '-1'
      RuleAction: allow
      Egress: 'false'
      CidrBlock: 0.0.0.0/0
  NetworkAclEntryPublicOutboundAll:
    Type: AWS::EC2::NetworkAclEntry
    Properties:
      NetworkAclId: !Ref 'NetworkAclPublic'
      RuleNumber: '100'
      Protocol: '-1'
      RuleAction: allow
      Egress: 'true'
      CidrBlock: 0.0.0.0/0
  SubnetNetworkAclAssociationPublicA:
    Type: AWS::EC2::SubnetNetworkAclAssociation
    Properties:
      SubnetId: !Ref 'SubnetPublicA'
      NetworkAclId: !Ref 'NetworkAclPublic'
  SubnetNetworkAclAssociationPublicB:
    Type: AWS::EC2::SubnetNetworkAclAssociation
    Properties:
      SubnetId: !Ref 'SubnetPublicB'
      NetworkAclId: !Ref 'NetworkAclPublic'
  SubnetNetworkAclAssociationPublicC:
    Type: AWS::EC2::SubnetNetworkAclAssociation
    Properties:
      SubnetId: !Ref 'SubnetPublicC'
      NetworkAclId: !Ref 'NetworkAclPublic'
  SubnetPrivateA:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref 'VPC'
      CidrBlock: !Ref 'CIDRPrivateA'
      AvailabilityZone: !Sub "${AWS::Region}a"
      Tags:
      - Key: Name
        Value: !Sub "${VPCName}-private-a"
  SubnetPrivateB:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref 'VPC'
      CidrBlock: !Ref 'CIDRPrivateB'
      AvailabilityZone: !Sub "${AWS::Region}b"
      Tags:
      - Key: Name
        Value: !Sub "${VPCName}-private-b"
  SubnetPrivateC:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref 'VPC'
      CidrBlock: !Ref 'CIDRPrivateC'
      AvailabilityZone: !Sub "${AWS::Region}c"
      Tags:
      - Key: Name
        Value: !Sub "${VPCName}-private-c"
  RouteTablePrivateA:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref 'VPC'
      Tags:
      - Key: Name
        Value: !Sub "${VPCName}-private-a"
  RouteTablePrivateB:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref 'VPC'
      Tags:
      - Key: Name
        Value: !Sub "${VPCName}-private-b"
  RouteTablePrivateC:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref 'VPC'
      Tags:
      - Key: Name
        Value: !Sub "${VPCName}-private-c"
  RoutePrivateA:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref 'RouteTablePrivateA'
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId: !Ref 'NATGWA'
  RoutePrivateB:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref 'RouteTablePrivateB'
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId: !If [ShouldCreateRedundantNAT, !Ref NATGWB, !Ref NATGWA]
  RoutePrivateC:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref 'RouteTablePrivateC'
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId: !If [ShouldCreateRedundantNAT, !Ref NATGWC, !Ref NATGWA]
  SubnetRouteTableAssociationPrivateA:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref 'SubnetPrivateA'
      RouteTableId: !Ref 'RouteTablePrivateA'
  SubnetRouteTableAssociationPrivateB:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref 'SubnetPrivateB'
      RouteTableId: !Ref 'RouteTablePrivateB'
  SubnetRouteTableAssociationPrivateC:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref 'SubnetPrivateC'
      RouteTableId: !Ref 'RouteTablePrivateC'
  NetworkAclPrivate:
    Type: AWS::EC2::NetworkAcl
    Properties:
      VpcId: !Ref 'VPC'
      Tags:
      - Key: Name
        Value: !Sub "${VPCName}-NACL-private"
  NetworkAclEntryPrivateInbound:
    Type: AWS::EC2::NetworkAclEntry
    Properties:
      NetworkAclId: !Ref 'NetworkAclPrivate'
      RuleNumber: '100'
      Protocol: '-1'
      RuleAction: allow
      Egress: 'false'
      CidrBlock: !Ref 'CIDRVPC'
      PortRange:
        From: '0'
        To: '65535'
  NetworkAclEntryPrivateOutbound:
    Type: AWS::EC2::NetworkAclEntry
    Properties:
      NetworkAclId: !Ref 'NetworkAclPrivate'
      RuleNumber: '100'
      Protocol: '-1'
      RuleAction: allow
      Egress: 'true'
      CidrBlock: 0.0.0.0/0
      PortRange:
        From: '0'
        To: '65535'
  SubnetNetworkAclAssociationPrivateA:
    Type: AWS::EC2::SubnetNetworkAclAssociation
    Properties:
      SubnetId: !Ref 'SubnetPrivateA'
      NetworkAclId: !Ref 'NetworkAclPrivate'
  SubnetNetworkAclAssociationPrivateB:
    Type: AWS::EC2::SubnetNetworkAclAssociation
    Properties:
      SubnetId: !Ref 'SubnetPrivateB'
      NetworkAclId: !Ref 'NetworkAclPrivate'
  SubnetNetworkAclAssociationPrivateC:
    Type: AWS::EC2::SubnetNetworkAclAssociation
    Properties:
      SubnetId: !Ref 'SubnetPrivateC'
      NetworkAclId: !Ref 'NetworkAclPrivate'
  SubnetRestrictedA:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref 'VPC'
      CidrBlock: !Ref 'CIDRRestrictedA'
      AvailabilityZone: !Sub "${AWS::Region}a"
      Tags:
      - Key: Name
        Value: !Sub "${VPCName}-restricted-a"
  SubnetRestrictedB:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref 'VPC'
      CidrBlock: !Ref 'CIDRRestrictedB'
      AvailabilityZone: !Sub "${AWS::Region}b"
      Tags:
      - Key: Name
        Value: !Sub "${VPCName}-restricted-b"
  SubnetRestrictedC:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref 'VPC'
      CidrBlock: !Ref 'CIDRRestrictedC'
      AvailabilityZone: !Sub "${AWS::Region}c"
      Tags:
      - Key: Name
        Value: !Sub "${VPCName}-restricted-c"
  RouteTableRestrictedA:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref 'VPC'
      Tags:
      - Key: Name
        Value: !Sub "${VPCName}-restricted-a"
  RouteTableRestrictedB:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref 'VPC'
      Tags:
      - Key: Name
        Value: !Sub "${VPCName}-restricted-b"
  RouteTableRestrictedC:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref 'VPC'
      Tags:
      - Key: Name
        Value: !Sub "${VPCName}-restricted-c"
  SubnetRouteTableAssociationRestrictedA:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref 'SubnetRestrictedA'
      RouteTableId: !Ref 'RouteTableRestrictedA'
  SubnetRouteTableAssociationRestrictedB:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref 'SubnetRestrictedB'
      RouteTableId: !Ref 'RouteTableRestrictedB'
  SubnetRouteTableAssociationRestrictedC:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref 'SubnetRestrictedC'
      RouteTableId: !Ref 'RouteTableRestrictedC'
  NetworkAclRestricted:
    Type: AWS::EC2::NetworkAcl
    Properties:
      VpcId: !Ref 'VPC'
      Tags:
      - Key: Name
        Value: !Sub "${VPCName}-NACL-restricted"
  NetworkAclEntryRestrictedInboundPrivate:
    Type: AWS::EC2::NetworkAclEntry
    Properties:
      NetworkAclId: !Ref 'NetworkAclRestricted'
      RuleNumber: '110'
      Protocol: '-1'
      RuleAction: allow
      Egress: 'false'
      CidrBlock: !Ref 'CIDRPrivateSummary'
      PortRange:
        From: '0'
        To: '65535'
  NetworkAclEntryRestrictedInboundRestricted:
    Type: AWS::EC2::NetworkAclEntry
    Properties:
      NetworkAclId: !Ref 'NetworkAclRestricted'
      RuleNumber: '120'
      Protocol: '-1'
      RuleAction: allow
      Egress: 'false'
      CidrBlock: !Ref 'CIDRRestrictedSummary'
      PortRange:
        From: '0'
        To: '65535'
  NetworkAclEntryPrivateInbound200:
    Type: AWS::EC2::NetworkAclEntry
    Properties:
      NetworkAclId: !Ref 'NetworkAclPrivate'
      RuleNumber: '200'
      Protocol: '6'
      RuleAction: allow
      Egress: 'false'
      CidrBlock: 0.0.0.0/0
      PortRange:
        From: '1024'
        To: '65535'
  NetworkAclEntryRestrictedOutbound:
    Type: AWS::EC2::NetworkAclEntry
    Properties:
      NetworkAclId: !Ref 'NetworkAclRestricted'
      RuleNumber: '100'
      Protocol: '-1'
      RuleAction: allow
      Egress: 'true'
      CidrBlock: 0.0.0.0/0
      PortRange:
        From: '0'
        To: '65535'
  SubnetNetworkAclAssociationRestrictedA:
    Type: AWS::EC2::SubnetNetworkAclAssociation
    Properties:
      SubnetId: !Ref 'SubnetRestrictedA'
      NetworkAclId: !Ref 'NetworkAclRestricted'
  SubnetNetworkAclAssociationRestrictedB:
    Type: AWS::EC2::SubnetNetworkAclAssociation
    Properties:
      SubnetId: !Ref 'SubnetRestrictedB'
      NetworkAclId: !Ref 'NetworkAclRestricted'
  SubnetNetworkAclAssociationRestrictedC:
    Type: AWS::EC2::SubnetNetworkAclAssociation
    Properties:
      SubnetId: !Ref 'SubnetRestrictedC'
      NetworkAclId: !Ref 'NetworkAclRestricted'
  EIPNATA:
    Type: AWS::EC2::EIP
    Properties:
      Domain: vpc
  EIPNATB:
    Type: AWS::EC2::EIP
    Condition: ShouldCreateRedundantNAT
    Properties:
      Domain: vpc
  EIPNATC:
    Type: AWS::EC2::EIP
    Condition: ShouldCreateRedundantNAT
    Properties:
      Domain: vpc
  NATGWA:
    Type: AWS::EC2::NatGateway
    DependsOn:
    - VPCGatewayAttachment
    - EIPNATA
    Properties:
      AllocationId: !GetAtt EIPNATA.AllocationId
      SubnetId: !If [ShouldCreateRedundantNAT, !Ref SubnetPublicA, !GetAtt RandomSubnet.Choice]
  NATGWB:
    Type: AWS::EC2::NatGateway
    DependsOn:
    - VPCGatewayAttachment
    - EIPNATB
    Condition: ShouldCreateRedundantNAT
    Properties:
      AllocationId: !GetAtt EIPNATB.AllocationId
      SubnetId: !Ref SubnetPublicB
  NATGWC:
    Type: AWS::EC2::NatGateway
    DependsOn:
    - VPCGatewayAttachment
    - EIPNATC
    Condition: ShouldCreateRedundantNAT
    Properties:
      AllocationId: !GetAtt EIPNATC.AllocationId
      SubnetId: !Ref SubnetPublicC
  SecurityGroupDefault:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: The default security group for the VPC
      VpcId: !Ref VPC
      SecurityGroupEgress:
      - CidrIp: 127.0.0.1/32
        IpProtocol: "-1"
      Tags:
      - Key: Name
        Value: !Sub "${VPCName}-base"

  VPCFlowlogRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - 'vpc-flow-logs.amazonaws.com'
          Action: 'sts:AssumeRole'
      Policies:
      - PolicyName: !Sub "${VPCName}-flowlogs-policy"
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
            - 'logs:PutLogEvents'
            Resource:
            - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:${AWS::StackName}*"
          - Effect: Allow
            Action:
            - 'logs:CreateLogGroup'
            - 'logs:CreateLogStream'
            - 'logs:DescribeLogGroups'
            - 'logs:DescribeLogStreams'
            Resource:
            - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:*"

  VPCFlowlogLogGroup:
    Type: 'AWS::Logs::LogGroup'
    Properties:
      RetentionInDays: !Ref FlowLogRetentionPeriod

  VPCFlowlogs:
    Type: AWS::EC2::FlowLog
    Properties:
      DeliverLogsPermissionArn: !GetAtt VPCFlowlogRole.Arn
      LogGroupName: !Ref VPCFlowlogLogGroup
      ResourceId: !Ref VPC
      ResourceType: VPC
      TrafficType: ALL

  ACMApproverRole:
    Type: "AWS::IAM::Role"
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W11
            reason: "IAM only supports *"
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: "sts:AssumeRole"
      Path: "/"
      Policies:
        -
          PolicyName: "ACMCFNLambdaPolicy"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              -
                Effect: "Allow"
                Action:
                  - "logs:CreateLogGroup"
                  - "logs:CreateLogStream"
                  - "logs:PutLogEvents"
                Resource: "*"
              -
                Effect: "Allow"
                Action:
                  - "acm:DescribeCertificate"
                  - "acm:ListCertificates"
                  - "acm:RequestCertificate"
                  - "route53:ChangeResourceRecordSets"
                  - "route53:ListHostedZones"
                Resource: "*"

  ACMApproverFunction:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          import sys,os,json,datetime,boto3,traceback,time,hashlib
          from botocore.vendored import requests
          from datetime import date, datetime
          def json_serial(obj):
              if isinstance(obj, (datetime, date)):
                  return obj.isoformat()
              raise TypeError ("Type %s not serializable" % type(obj))
          def cfn_response(url, body):
              headers = {'content-type' : '','content-length' : str(len(body))}
              response = requests.put(url,data=body,headers=headers)
          def acm_certificate(event, context):
              print "Got %s" % json.dumps(event, default=json_serial)
              if event['RequestType'] in ['Create','Update']:
                  cfn_response(event['ResponseURL'], _create_acm_certificate(event))
              else:
                  cfn_response(event['ResponseURL'], _delete_acm_certificate(event))
          def _create_acm_certificate(event):
              acm = boto3.client('acm')
              ret = {}
              ret['StackId'] = event['StackId']
              ret['RequestId'] = event['RequestId']
              ret['LogicalResourceId'] = event['LogicalResourceId']
              rp = event['ResourceProperties']
              try:
                  cs = rp['DomainSuffix'].rstrip('.')
                  dn = "%s.%s" % (rp['DomainName'].rstrip('.'), cs)
                  san = [dn]
                  if 'SAN' in rp:
                      san.extend(rp['SAN'])
                  if len(dn) > 62:
                      hashlen = 62-len(cs)
                      ch = hashlib.sha256(dn).hexdigest()[-hashlen:]
                      dn = "%s.%s" % (ch, cs)
                  response = acm.list_certificates(
                      CertificateStatuses=['PENDING_VALIDATION','ISSUED']
                  )
                  cert_arn = None
                  for cert in response['CertificateSummaryList']:
                      print "existing cert: %s" % cert['DomainName']
                      if cert['DomainName'] == dn:
                          cert_arn = cert['CertificateArn']

                  if not cert_arn:
                      response = acm.request_certificate(
                          DomainName=dn,
                          ValidationMethod='DNS',
                          IdempotencyToken=event['LogicalResourceId'],
                          SubjectAlternativeNames = san
                      )
                      cert_arn = response['CertificateArn']
                      time.sleep(10)

                  response = acm.describe_certificate(
                      CertificateArn=cert_arn
                  )
                  r53_c = []
                  for vo in response['Certificate']['DomainValidationOptions']:
                      rr = vo['ResourceRecord']
                      r53_c.append({'Action':'UPSERT','ResourceRecordSet':{'Name': rr['Name'],'Type': rr['Type'],'TTL': 3600,'ResourceRecords': [{'Value': rr['Value']}]}})
                  r53 = boto3.client('route53')
                  if 'HostedZoneName' in rp:
                      for hz in r53.list_hosted_zones()["HostedZones"]:
                          if hz['Name'].rstrip('.') == rp['HostedZoneName'].rstrip('.'):
                              rp['HostedZoneId'] = hz['Id']
                  response = r53.change_resource_record_sets(
                      HostedZoneId=rp['HostedZoneId'],
                      ChangeBatch={'Comment':'Auth','Changes':r53_c}
                  )
                  time.sleep(220)

                  ret['PhysicalResourceId'] = cert_arn
                  ret['Data'] = {}
                  ret['Data']['CertificateArn'] = cert_arn
                  ret['Status'] = 'SUCCESS'
              except:
                  traceback.print_exc()
                  ret['Status'] = 'FAILED'
                  ret['Reason'] = 'Good question'
              finally:
                  cfn_response(event['ResponseURL'], json.dumps(ret))
              return json.dumps(ret)

          def _delete_acm_certificate(event):
              acm = boto3.client('acm')
              ret = {}
              ret['StackId'] = event['StackId']
              ret['RequestId'] = event['RequestId']
              ret['LogicalResourceId'] = event['LogicalResourceId']
              ret['PhysicalResourceId'] = event['PhysicalResourceId']
              try:
                  #response = acm.delete_certificate(
                  #    CertificateArn=event['PhysicalResourceId']
                  #)
                  #print "got response %s" % json.dumps(response, default=json_serial)
                  ret['Status'] = 'SUCCESS'
              except:
                  traceback.print_exc()
                  ret['Status'] = 'SUCCESS'
                  ret['Reason'] = 'Good question'
              finally:
                  cfn_response(event['ResponseURL'], json.dumps(ret))

              return json.dumps(ret)

      Description: Cloudformation Custom Resource for ACM certs using Route53 approval
      Handler: index.acm_certificate
      MemorySize: 256
      Runtime: python2.7
      Timeout: 300
      Role:
        Fn::GetAtt: ACMApproverRole.Arn

  RandomSubnet:
    Type: Custom::Randomizer
    Condition: NoRedundantNAT
    Properties:
      ServiceToken: !GetAtt Randomizer.Arn
      Choices:
        - !Ref SubnetPublicA
        - !Ref SubnetPublicB
        - !Ref SubnetPublicC

  Randomizer:
    Type: AWS::Lambda::Function
    Condition: NoRedundantNAT
    Properties:
      Runtime: python2.7
      Handler: index.lambda_handler
      MemorySize: 128
      Role: !GetAtt RandomizerRole.Arn
      Timeout: 30
      Code:
        ZipFile: !Sub |
          import cfnresponse
          import random
          import uuid

          def lambda_handler(event, context):
            response_data = {}
            choices = event['ResourceProperties']['Choices']
            response_data['Choice'] = random.choice(choices)
            print "Randomly selected %s out of %s" % (response_data['Choice'], choices)
            cfnresponse.send(event, context, cfnresponse.SUCCESS, response_data, str(uuid.uuid4()))

  RandomizerRole:
    Type: AWS::IAM::Role
    Condition: NoRedundantNAT
    Properties:
      Path: /
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: root
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: "*"

  SubdomainHostedZone:
    Type: AWS::Route53::HostedZone
    Condition: CreateHostedZone
    Properties:
      HostedZoneConfig:
        Comment: "Subdomain for VPC"
      Name: !Sub "${DomainName}."

Outputs:
  NATAIPAddress:
    Value: !Ref 'EIPNATA'
  NATBIPAddress:
    Condition: ShouldCreateRedundantNAT
    Value: !Ref 'EIPNATB'
  NATCIPAddress:
    Condition: ShouldCreateRedundantNAT
    Value: !Ref 'EIPNATC'
  VPCID:
    Value: !Ref 'VPC'
    Export:
      Name: !Sub "${AWS::StackName}-VPCID"
  VPCCIDR:
    Value: !Ref CIDRVPC
    Export:
      Name: !Sub "${AWS::StackName}-VPCCIDR"
  SubnetPublicA:
    Value: !Ref 'SubnetPublicA'
    Export:
      Name: !Sub "${AWS::StackName}-SubnetPublicA"
  SubnetPublicB:
    Value: !Ref 'SubnetPublicB'
    Export:
      Name: !Sub "${AWS::StackName}-SubnetPublicB"
  SubnetPublicC:
    Value: !Ref 'SubnetPublicC'
    Export:
      Name: !Sub "${AWS::StackName}-SubnetPublicC"
  SubnetPrivateA:
    Value: !Ref 'SubnetPrivateA'
    Export:
      Name: !Sub "${AWS::StackName}-SubnetPrivateA"
  SubnetPrivateB:
    Value: !Ref 'SubnetPrivateB'
    Export:
      Name: !Sub "${AWS::StackName}-SubnetPrivateB"
  SubnetPrivateC:
    Value: !Ref 'SubnetPrivateC'
    Export:
      Name: !Sub "${AWS::StackName}-SubnetPrivateC"
  SubnetRestrictedA:
    Value: !Ref 'SubnetRestrictedA'
    Export:
      Name: !Sub "${AWS::StackName}-SubnetRestrictedA"
  SubnetRestrictedB:
    Value: !Ref 'SubnetRestrictedB'
    Export:
      Name: !Sub "${AWS::StackName}-SubnetRestrictedB"
  SubnetRestrictedC:
    Value: !Ref 'SubnetRestrictedC'
    Export:
      Name: !Sub "${AWS::StackName}-SubnetRestrictedC"
  HostedZoneName:
    Condition: CreateHostedZone
    Value: !Ref DomainName
    Export:
      Name: !Sub "${AWS::StackName}-HostedZoneName"
  HostedZoneId:
    Condition: CreateHostedZone
    Value: !Ref SubdomainHostedZone
    Export:
      Name: !Sub "${AWS::StackName}-HostedZoneId"
  ACMCertificateToken:
    Value: !GetAtt ACMApproverFunction.Arn
    Export:
      Name: !Sub "${AWS::StackName}-ACMCertificateToken"
  VpcStackName:
    Value: !Sub "${AWS::StackName}"